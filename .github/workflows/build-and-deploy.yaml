#.github/workflows/build-and-deploy.yaml

name: Build and Deploy Image

on:
  push:
    branches: [ "main" ]                                        # workflow is triggered on each push to main branch 
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/nicolasdiez/video2text

jobs:
  build:
    runs-on: [self-hosted, Linux, ci-debian-bookworm-01, X64]   # all tags have to match with the ones defined in GitHub Repo --> Actions --> Runners --> Self-hosted Runners
    steps:
      - name: Checkout                                          # fetch my github repo
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push                                    # build docker image from Dockerfile, and push it to GitHub Container Registry (when 'push: true')
        uses: docker/build-push-action@v6                       # 'build-push-action@v6' is a reusable GitHub Action, which under the hood runs "docker buildx build", which uses the ./Dockerfile
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          # cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache          # registry cache ref so subsequent runs reuse layer cache from GHCR
          # cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max   # registry cache ref so subsequent runs reuse layer cache from GHCR


  deploy-and-test:
    runs-on: [self-hosted, Linux, ci-debian-bookworm-01, X64]
    needs: build
    environment: production                                      # must have full match to the exact name of the Environment in Github repo --> Settings --> Secrets and variables --> Actions --> Environment secrets. Otherwise the workflow wonÂ´t have access to the vars and secrets.
    timeout-minutes: 120
    steps:
      - name: Checkout                                          # needed to generate .env.ci file from vars/secrets locales
        uses: actions/checkout@v4

      - name: Create env file from GitHub Secrets (full)        # create .env file with the vars and secrets to further use it as input to run the containerized application
        run: |
          cat > .env.ci <<EOF
          APP_DEBUG=${{ vars.APP_DEBUG }}
          LOG_LEVEL=${{ vars.LOG_LEVEL }}
          ENVIRONMENT=${{ vars.ENVIRONMENT }}
          YOUTUBE_API_KEY=${{ secrets.YOUTUBE_API_KEY }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          MONGO_USER=${{ secrets.MONGO_USER }}
          MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}
          MONGO_HOST=${{ secrets.MONGO_HOST }}
          MONGO_DB=${{ secrets.MONGO_DB }}
          X_OAUTH1_API_KEY=${{ secrets.X_OAUTH1_API_KEY }}
          X_OAUTH1_API_SECRET=${{ secrets.X_OAUTH1_API_SECRET }}
          X_OAUTH2_API_BEARER_TOKEN=${{ secrets.X_OAUTH2_API_BEARER_TOKEN }}
          X_OAUTH2_CLIENT_ID=${{ secrets.X_OAUTH2_CLIENT_ID }}
          X_OAUTH2_CLIENT_SECRET=${{ secrets.X_OAUTH2_CLIENT_SECRET }}
          DB_ENCRIPTION_SECRET_KEY=${{ secrets.DB_ENCRIPTION_SECRET_KEY }}
          X_OAUTH1_ACCESS_TOKEN=${{ secrets.X_OAUTH1_ACCESS_TOKEN }}
          X_OAUTH1_ACCESS_TOKEN_SECRET=${{ secrets.X_OAUTH1_ACCESS_TOKEN_SECRET }}
          X_OAUTH2_ACCESS_TOKEN=${{ secrets.X_OAUTH2_ACCESS_TOKEN }}
          X_OAUTH2_ACCESS_TOKEN_EXPIRES_AT=${{ secrets.X_OAUTH2_ACCESS_TOKEN_EXPIRES_AT }}
          X_OAUTH2_REFRESH_TOKEN=${{ secrets.X_OAUTH2_REFRESH_TOKEN }}
          X_OAUTH2_REFRESH_TOKEN_EXPIRES_AT=${{ secrets.X_OAUTH2_REFRESH_TOKEN_EXPIRES_AT }}
          X_SCREEN_NAME=${{ secrets.X_SCREEN_NAME }}
          YOUTUBE_OAUTH_CLIENT_ID=${{ secrets.YOUTUBE_OAUTH_CLIENT_ID }}
          YOUTUBE_OAUTH_CLIENT_SECRET=${{ secrets.YOUTUBE_OAUTH_CLIENT_SECRET }}
          YOUTUBE_OAUTH_CLIENT_REFRESH_TOKEN=${{ secrets.YOUTUBE_OAUTH_CLIENT_REFRESH_TOKEN }}
          EOF
        shell: bash

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-pull image                                    # reduce time at the critical step by pulling ahead
        run: |
          docker pull ${{ env.IMAGE_NAME }}:latest || true

      - name: Pull image
        run: docker pull ${{ env.IMAGE_NAME }}:latest

      - name: Run container (detached)                          # run a container named sut-_ID (detached = non-blocking action for the runner step). Before run ensure no leftover container exists.
        run: |
          # Use a run-unique name and label so we don't collide with production containers
          NAME="sut-${{ github.run_id }}"
          # Remove any existing previous leftovr containers
          docker rm -f "$NAME" || true
          # Now, run the new container
          docker run -d --name "$NAME" --label gh_workflow=video2text --restart unless-stopped -p 8000:8000 --env-file .env.ci ${{ env.IMAGE_NAME }}:latest
          echo "CONTAINER_NAME=$NAME" >> $GITHUB_ENV    

      - name: Healthcheck                                        # because the container was started detached, we should check that the service started properly
        run: |
          for i in $(seq 1 20); do
            status=$(curl -s -o /tmp/resp -w "%{http_code}" http://localhost:8000/docs || echo "000")
            if [ "$status" = "200" ]; then
              echo "health ok"
              exit 0
            fi
            sleep 3
          done
          echo "healthcheck failed; dumping last logs"
          docker logs --tail 200 "$CONTAINER_NAME" || true
          exit 1

#      - name: Cleanup (optional) 
#        if: always()
#        run: |
#          docker stop "$CONTAINER_NAME" || true
#          docker rm -f "$CONTAINER_NAME" || true
