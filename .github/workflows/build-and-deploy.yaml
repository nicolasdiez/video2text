#.github/workflows/build-and-deploy.yaml

name: Build and Deploy to Self-Hosted Runner VM

on:
  push:
    branches: [ "main" ]                                        # workflow is triggered on each push to main branch 
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: ghcr.io/nicolasdiez/video2text

jobs:
  build:
    runs-on: ubuntu-latest                                        # run on github-hosted runner
    # runs-on: [self-hosted, Linux, ci-debian-bookworm-01, X64]   # run on self-hosted runner (all these tags have to match with the ones defined in GitHub Repo --> Actions --> Runners --> Self-hosted Runners)
    steps:
      - name: Checkout                                            # fetch the project github repo
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry                 # authenticates the runner into ghcr.io so the image push ahead succeeds
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Image and Push to GHCR                                    # build docker image from Dockerfile, and push it to GitHub Container Registry (when 'push: true')
        uses: docker/build-push-action@v6                         # 'build-push-action@v6' is a reusable GitHub Action, which under the hood runs "docker buildx build", which uses the ./Dockerfile
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          # cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache          # registry cache ref so subsequent runs reuse layer cache from GHCR
          # cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max   # registry cache ref so subsequent runs reuse layer cache from GHCR

  deploy-and-test:
    runs-on: [self-hosted, Linux, ci-debian-bookworm-01, X64]
    needs: build
    environment: production                                      # must have full match to the exact name of the Environment in Github repo --> Settings --> Secrets and variables --> Actions --> Environment secrets. Otherwise the workflow wonÂ´t have access to the vars and secrets.
    timeout-minutes: 120
    steps:
      - name: Checkout                                          # fetch the project github repo (needed to generate .env.ci file with the vars/secrets)
        uses: actions/checkout@v4

      - name: Create env file from GitHub Secrets (full)        # create .env file with the vars and secrets to further use it as input to run the containerized application
        run: |
          cat > .env.ci <<EOF
          APP_DEBUG=${{ vars.APP_DEBUG }}
          LOG_LEVEL=${{ vars.LOG_LEVEL }}
          ENVIRONMENT=${{ vars.ENVIRONMENT }}
          YOUTUBE_API_KEY=${{ secrets.YOUTUBE_API_KEY }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          MONGO_USER=${{ secrets.MONGO_USER }}
          MONGO_PASSWORD=${{ secrets.MONGO_PASSWORD }}
          MONGO_HOST=${{ secrets.MONGO_HOST }}
          MONGO_DB=${{ secrets.MONGO_DB }}
          X_OAUTH1_API_KEY=${{ secrets.X_OAUTH1_API_KEY }}
          X_OAUTH1_API_SECRET=${{ secrets.X_OAUTH1_API_SECRET }}
          X_OAUTH2_API_BEARER_TOKEN=${{ secrets.X_OAUTH2_API_BEARER_TOKEN }}
          X_OAUTH2_CLIENT_ID=${{ secrets.X_OAUTH2_CLIENT_ID }}
          X_OAUTH2_CLIENT_SECRET=${{ secrets.X_OAUTH2_CLIENT_SECRET }}
          DB_ENCRIPTION_SECRET_KEY=${{ secrets.DB_ENCRIPTION_SECRET_KEY }}
          X_OAUTH1_ACCESS_TOKEN=${{ secrets.X_OAUTH1_ACCESS_TOKEN }}
          X_OAUTH1_ACCESS_TOKEN_SECRET=${{ secrets.X_OAUTH1_ACCESS_TOKEN_SECRET }}
          X_OAUTH2_ACCESS_TOKEN=${{ secrets.X_OAUTH2_ACCESS_TOKEN }}
          X_OAUTH2_ACCESS_TOKEN_EXPIRES_AT=${{ secrets.X_OAUTH2_ACCESS_TOKEN_EXPIRES_AT }}
          X_OAUTH2_REFRESH_TOKEN=${{ secrets.X_OAUTH2_REFRESH_TOKEN }}
          X_OAUTH2_REFRESH_TOKEN_EXPIRES_AT=${{ secrets.X_OAUTH2_REFRESH_TOKEN_EXPIRES_AT }}
          X_SCREEN_NAME=${{ secrets.X_SCREEN_NAME }}
          YOUTUBE_OAUTH_CLIENT_ID=${{ secrets.YOUTUBE_OAUTH_CLIENT_ID }}
          YOUTUBE_OAUTH_CLIENT_SECRET=${{ secrets.YOUTUBE_OAUTH_CLIENT_SECRET }}
          YOUTUBE_OAUTH_CLIENT_REFRESH_TOKEN=${{ secrets.YOUTUBE_OAUTH_CLIENT_REFRESH_TOKEN }}
          EOF
        shell: bash

      - name: Log in to GHCR                                    # authenticates the runner into ghcr.io so the image pull ahead succeeds
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-Pull image from GHCR                          # reduce time at the critical step by pulling ahead image from GHCR
        run: docker pull ${{ env.IMAGE_NAME }}:latest

      - name: Ensure container port is free                     # free port that will be used by the container
        run: |
          set -euo pipefail

          # 1) Try to read EXPOSE from Dockerfile
          PORT=$(grep -i '^EXPOSE' Dockerfile | awk '{print $2; exit}' || true)

          # 2) If no EXPOSE, try to parse --port from CMD line (basic extraction)
          if [ -z "$PORT" ]; then
            PORT=$(grep -oE '--port[= ]*[0-9]+' Dockerfile | head -n1 | sed -E 's/[^0-9]*([0-9]+).*/\1/' || true)
          fi

          # 3) Fallback to default 8000
          if [ -z "$PORT" ]; then
            echo "No EXPOSE or --port found in Dockerfile; defaulting to 8000"
            PORT=8000
          fi

          echo "Checking port: $PORT"

          # 4) Check if any process is listening on the port
          if ss -ltn "( sport = :$PORT )" >/dev/null 2>&1; then
            echo "Port $PORT is in use. Detecting owning docker containers (if any)..."

            # 5) Find docker containers that publish this host port (match common docker ps Ports format)
            CONTAINERS=$(docker ps --format '{{.ID}} {{.Ports}}' | awk -v p=":$PORT" '$0 ~ p {print $1}' || true)

            if [ -n "$CONTAINERS" ]; then
              echo "Stopping containers that publish port $PORT: $CONTAINERS"
              for c in $CONTAINERS; do
                docker rm -f "$c" || true
              done
              echo "Stopped containers: $CONTAINERS"
            else
              # 6) If no docker container found, detect non-docker PID using lsof/ss
              PID=$(ss -ltnp "( sport = :$PORT )" | awk -F 'pid=' '/LISTEN/ {print $2; exit}' | cut -d',' -f1 || true)
              if [ -n "$PID" ]; then
                echo "Port $PORT is held by non-container process PID $PID. Cannot auto-stop non-container processes."
                ss -ltnp "( sport = :$PORT )" || true
                exit 1
              else
                echo "Port $PORT appears in use but no owning PID found; aborting."
                ss -ltnp "( sport = :$PORT )" || true
                exit 1
              fi
            fi
          else
            echo "Port $PORT is free."
          fi

      - name: Run container (detached)                          # run a container named sut-_ID (detached = non-blocking action for the runner step). Before run ensure no leftover container exists.
        run: |
          # Use a run-unique name and label so we don't collide with production containers
          NAME="sut-${{ github.run_id }}"
          # Remove any existing previous leftovr containers
          docker rm -f "$NAME" || true
          # Now, run the new container
          docker run -d --name "$NAME" --label gh_workflow=video2text --restart unless-stopped -p 8000:8000 --env-file .env.ci ${{ env.IMAGE_NAME }}:latest
          echo "CONTAINER_NAME=$NAME" >> $GITHUB_ENV    

      - name: Healthcheck                                        # because the container was started detached, we should check that the service started properly
        run: |
          for i in $(seq 1 20); do
            status=$(curl -s -o /tmp/resp -w "%{http_code}" http://localhost:8000/docs || echo "000")
            if [ "$status" = "200" ]; then
              echo "health ok"
              exit 0
            fi
            sleep 3
          done
          echo "healthcheck failed; dumping last logs"
          docker logs --tail 200 "$CONTAINER_NAME" || true
          exit 1

#      - name: Cleanup (optional) 
#        if: always()
#        run: |
#          docker stop "$CONTAINER_NAME" || true
#          docker rm -f "$CONTAINER_NAME" || true
