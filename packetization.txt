video2text/
├── domain/
│   ├── entities/
│   │   ├── user.py
│   │   ├── channel.py
│   │   ├── video.py
│   │   ├── tweet_generation.py
│   │   └── tweet.py
│   └── ports/
│       ├── inbound/
│       │   └─
│       └── outbound/
│           ├── mongodb/
│           │   ├── user_repository.py
│           │   ├── channel_repository.py
│           │   ├── video_repository.py
│           │   ├── tweet_generation_repository.py
│           │   ├── tweet_repository.py
│           ├── video_source_port.py
│           ├── transcription_port.py
│           ├── openai_port.py
│           ├── prompt_loader_port.py
│           └── twitter_port.py
│
├── adapters/
│   ├── inbound/
│   │   └─
│   └── outbound/
│       ├── mongodb/
│       │   ├── user_repository.py
│       │   ├── channel_repository.py
│       │   ├── video_repository.py
│       │   ├── tweet_repository.py
│       │   └── tweet_generation_repository.py
│       ├── youtube_video_client.py
│       ├── transcription_client.py
│       ├── file_prompt_loader.py
│       ├── openai_client.py
│       └── twitter_client.py
│
├── application/
│   └── services/
│       ├── user_service.py
│       ├── channel_service.py
│       ├── video_service.py
│       ├── tweet_generation_service.py
│       └── pipeline_service.py
│
├── infrastructure/
│   ├── config.py      # carga .env y Settings
│   └── monogdb.py     # inicializa AsyncIOMotorClient y exporta `db`
│
└── main.py            # arranca FastAPI, registra routers de adapters/inbound/http/



# inbound
# domain/ports/inbound  --> definen de las interfaces que el core expone (casos de uso)
# application/services  --> implementan interfaces inbound, reciben por inyección los outbound-ports y orquestan la lógica de negocio
# adapters/inbound/http --> controladores (FastAPI, gRPC, CLI…) que inyectan los services y delegan en ellos
# main (wiring)         --> instanciar adapters/outbound → services → adapters/inbound y registrar rutas/comandos

# outbound
# domain/ports/outbound --> definen contratos para acceso a infra (DB, APIs, colas…), sin lógica propia.
# adapters/outbound     --> implementan los contratos domain/ports/outbound traduciendo entre entidades de dominio y formatos externos.
# application/services  --> usan los outbound-ports inyectados para ejecutar llamadas a infra dentro de la lógica de negocio.
# main (wiring)         --> crear adapters/outbound, pasarlos a los services y luego a los controllers (adapters) inbound.